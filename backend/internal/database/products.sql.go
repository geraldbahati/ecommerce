// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: products.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const addProduct = `-- name: AddProduct :one
INSERT INTO products (id, name, description, image_url, price, stock, category_id, brand, rating, review_count, discount_rate, keywords, is_active, created_at, last_updated)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, NOW(), NULL)
RETURNING id, name, description, image_url, price, stock, category_id, brand, rating, review_count, discount_rate, keywords, is_active, created_at, last_updated
`

type AddProductParams struct {
	ID           uuid.UUID
	Name         string
	Description  sql.NullString
	ImageUrl     sql.NullString
	Price        string
	Stock        int32
	CategoryID   uuid.UUID
	Brand        sql.NullString
	Rating       string
	ReviewCount  int32
	DiscountRate string
	Keywords     sql.NullString
	IsActive     bool
}

func (q *Queries) AddProduct(ctx context.Context, arg AddProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, addProduct,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.ImageUrl,
		arg.Price,
		arg.Stock,
		arg.CategoryID,
		arg.Brand,
		arg.Rating,
		arg.ReviewCount,
		arg.DiscountRate,
		arg.Keywords,
		arg.IsActive,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.Price,
		&i.Stock,
		&i.CategoryID,
		&i.Brand,
		&i.Rating,
		&i.ReviewCount,
		&i.DiscountRate,
		&i.Keywords,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastUpdated,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
UPDATE products SET
    is_active = FALSE
WHERE id = $1
RETURNING id, name, description, image_url, price, stock, category_id, brand, rating, review_count, discount_rate, keywords, is_active, created_at, last_updated
`

func (q *Queries) DeleteProduct(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteProduct, id)
	return err
}

const getAvailableProducts = `-- name: GetAvailableProducts :many
SELECT id, name, description, image_url, price, stock, category_id, brand, rating, review_count, discount_rate, keywords, is_active, created_at, last_updated FROM products
WHERE stock > 0 AND is_active = TRUE
`

func (q *Queries) GetAvailableProducts(ctx context.Context) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getAvailableProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Price,
			&i.Stock,
			&i.CategoryID,
			&i.Brand,
			&i.Rating,
			&i.ReviewCount,
			&i.DiscountRate,
			&i.Keywords,
			&i.IsActive,
			&i.CreatedAt,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilteredProducts = `-- name: GetFilteredProducts :many
SELECT id, name, description, image_url, price, stock, category_id, brand, rating, review_count, discount_rate, keywords, is_active, created_at, last_updated FROM products
WHERE category_id = $1 AND price <= $2
`

type GetFilteredProductsParams struct {
	CategoryID uuid.UUID
	Price      string
}

func (q *Queries) GetFilteredProducts(ctx context.Context, arg GetFilteredProductsParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getFilteredProducts, arg.CategoryID, arg.Price)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Price,
			&i.Stock,
			&i.CategoryID,
			&i.Brand,
			&i.Rating,
			&i.ReviewCount,
			&i.DiscountRate,
			&i.Keywords,
			&i.IsActive,
			&i.CreatedAt,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaginatedProducts = `-- name: GetPaginatedProducts :many
SELECT id, name, description, image_url, price, stock, category_id, brand, rating, review_count, discount_rate, keywords, is_active, created_at, last_updated FROM products
ORDER BY created_at DESC
OFFSET $1 LIMIT $2
`

type GetPaginatedProductsParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) GetPaginatedProducts(ctx context.Context, arg GetPaginatedProductsParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getPaginatedProducts, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Price,
			&i.Stock,
			&i.CategoryID,
			&i.Brand,
			&i.Rating,
			&i.ReviewCount,
			&i.DiscountRate,
			&i.Keywords,
			&i.IsActive,
			&i.CreatedAt,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductById = `-- name: GetProductById :one
SELECT id, name, description, image_url, price, stock, category_id, brand, rating, review_count, discount_rate, keywords, is_active, created_at, last_updated FROM products
WHERE id = $1
`

func (q *Queries) GetProductById(ctx context.Context, id uuid.UUID) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProductById, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.Price,
		&i.Stock,
		&i.CategoryID,
		&i.Brand,
		&i.Rating,
		&i.ReviewCount,
		&i.DiscountRate,
		&i.Keywords,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastUpdated,
	)
	return i, err
}

const getProductWithRecommendations = `-- name: GetProductWithRecommendations :one
WITH current_product AS (
    SELECT id, name, description, image_url, price, stock, category_id, brand, rating, review_count, discount_rate, keywords, is_active, created_at, last_updated FROM products WHERE products.id = $1
)
SELECT cp.id, cp.name, cp.description, cp.image_url, cp.price, cp.stock, cp.category_id, cp.brand, cp.rating, cp.review_count, cp.discount_rate, cp.keywords, cp.is_active, cp.created_at, cp.last_updated,
    (
        SELECT jsonb_agg(jsonb_build_object('id',  rec.id, 'name',rec.name, 'price',rec.price))
        FROM products rec
        WHERE rec.category_id = cp.category_id AND rec.id != cp.id
        ORDER BY random()
        LIMIT 5
    ) AS recommendations
FROM current_product cp
`

type GetProductWithRecommendationsRow struct {
	ID              uuid.UUID
	Name            string
	Description     sql.NullString
	ImageUrl        sql.NullString
	Price           string
	Stock           int32
	CategoryID      uuid.UUID
	Brand           sql.NullString
	Rating          string
	ReviewCount     int32
	DiscountRate    string
	Keywords        sql.NullString
	IsActive        bool
	CreatedAt       time.Time
	LastUpdated     sql.NullTime
	Recommendations json.RawMessage
}

func (q *Queries) GetProductWithRecommendations(ctx context.Context, id uuid.UUID) (GetProductWithRecommendationsRow, error) {
	row := q.db.QueryRowContext(ctx, getProductWithRecommendations, id)
	var i GetProductWithRecommendationsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.Price,
		&i.Stock,
		&i.CategoryID,
		&i.Brand,
		&i.Rating,
		&i.ReviewCount,
		&i.DiscountRate,
		&i.Keywords,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.Recommendations,
	)
	return i, err
}

const getProducts = `-- name: GetProducts :many
SELECT id, name, description, image_url, price, stock, category_id, brand, rating, review_count, discount_rate, keywords, is_active, created_at, last_updated FROM products
`

func (q *Queries) GetProducts(ctx context.Context) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Price,
			&i.Stock,
			&i.CategoryID,
			&i.Brand,
			&i.Rating,
			&i.ReviewCount,
			&i.DiscountRate,
			&i.Keywords,
			&i.IsActive,
			&i.CreatedAt,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByCategory = `-- name: GetProductsByCategory :many
SELECT id, name, description, image_url, price, stock, category_id, brand, rating, review_count, discount_rate, keywords, is_active, created_at, last_updated FROM products
WHERE category_id = $1
`

func (q *Queries) GetProductsByCategory(ctx context.Context, categoryID uuid.UUID) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByCategory, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Price,
			&i.Stock,
			&i.CategoryID,
			&i.Brand,
			&i.Rating,
			&i.ReviewCount,
			&i.DiscountRate,
			&i.Keywords,
			&i.IsActive,
			&i.CreatedAt,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalesTrends = `-- name: GetSalesTrends :many
SELECT DATE_TRUNC('month', created_at) AS month, SUM(price) AS total_sales
FROM orders
GROUP BY month
ORDER BY month
`

type GetSalesTrendsRow struct {
	Month      int64
	TotalSales int64
}

func (q *Queries) GetSalesTrends(ctx context.Context) ([]GetSalesTrendsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSalesTrends)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSalesTrendsRow
	for rows.Next() {
		var i GetSalesTrendsRow
		if err := rows.Scan(&i.Month, &i.TotalSales); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProducts = `-- name: SearchProducts :many
SELECT id, name, description, image_url, price, stock, category_id, brand, rating, review_count, discount_rate, keywords, is_active, created_at, last_updated FROM products
WHERE name ILIKE '%' || $1 || '%' OR keywords ILIKE '%' || $1 || '%'
`

func (q *Queries) SearchProducts(ctx context.Context, dollar_1 sql.NullString) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, searchProducts, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Price,
			&i.Stock,
			&i.CategoryID,
			&i.Brand,
			&i.Rating,
			&i.ReviewCount,
			&i.DiscountRate,
			&i.Keywords,
			&i.IsActive,
			&i.CreatedAt,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products SET
    name = $2,
    description = $3,
    image_url = $4,
    price = $5,
    stock = $6,
    category_id = $7,
    brand = $8,
    rating = $9,
    review_count = $10,
    discount_rate = $11,
    keywords = $12,
    is_active = $13,
    last_updated = NOW()
WHERE id = $1
RETURNING id, name, description, image_url, price, stock, category_id, brand, rating, review_count, discount_rate, keywords, is_active, created_at, last_updated
`

type UpdateProductParams struct {
	ID           uuid.UUID
	Name         string
	Description  sql.NullString
	ImageUrl     sql.NullString
	Price        string
	Stock        int32
	CategoryID   uuid.UUID
	Brand        sql.NullString
	Rating       string
	ReviewCount  int32
	DiscountRate string
	Keywords     sql.NullString
	IsActive     bool
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, updateProduct,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.ImageUrl,
		arg.Price,
		arg.Stock,
		arg.CategoryID,
		arg.Brand,
		arg.Rating,
		arg.ReviewCount,
		arg.DiscountRate,
		arg.Keywords,
		arg.IsActive,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.Price,
		&i.Stock,
		&i.CategoryID,
		&i.Brand,
		&i.Rating,
		&i.ReviewCount,
		&i.DiscountRate,
		&i.Keywords,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastUpdated,
	)
	return i, err
}
