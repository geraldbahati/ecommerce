// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: products.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const addProduct = `-- name: AddProduct :one
INSERT INTO products (id, name, description, image_url, price, stock, category_id, brand, rating, review_count, discount_rate, keywords, is_active, created_at, last_updated)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 0.0, 0, 0.0, $9, TRUE, NOW(), NULL)
RETURNING id, name, description, image_url, price, stock, category_id, brand, rating, review_count, discount_rate, keywords, is_active, created_at, last_updated
`

type AddProductParams struct {
	ID          uuid.UUID
	Name        string
	Description sql.NullString
	ImageUrl    sql.NullString
	Price       string
	Stock       int32
	CategoryID  uuid.UUID
	Brand       sql.NullString
	Keywords    sql.NullString
}

func (q *Queries) AddProduct(ctx context.Context, arg AddProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, addProduct,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.ImageUrl,
		arg.Price,
		arg.Stock,
		arg.CategoryID,
		arg.Brand,
		arg.Keywords,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.Price,
		&i.Stock,
		&i.CategoryID,
		&i.Brand,
		&i.Rating,
		&i.ReviewCount,
		&i.DiscountRate,
		&i.Keywords,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastUpdated,
	)
	return i, err
}

const checkProductStock = `-- name: CheckProductStock :many
SELECT id FROM products
WHERE stock > 0
AND (last_updated > NOW() - INTERVAL '1 DAY')
`

func (q *Queries) CheckProductStock(ctx context.Context) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, checkProductStock)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteProduct = `-- name: DeleteProduct :exec
UPDATE products SET
    is_active = FALSE
WHERE id = $1
RETURNING id, name, description, image_url, price, stock, category_id, brand, rating, review_count, discount_rate, keywords, is_active, created_at, last_updated
`

func (q *Queries) DeleteProduct(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteProduct, id)
	return err
}

const getAvailableProducts = `-- name: GetAvailableProducts :many
SELECT id, name, description, image_url, price, stock, category_id, brand, rating, review_count, discount_rate, keywords, is_active, created_at, last_updated FROM products
WHERE stock > 0 AND is_active = TRUE
`

func (q *Queries) GetAvailableProducts(ctx context.Context) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getAvailableProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Price,
			&i.Stock,
			&i.CategoryID,
			&i.Brand,
			&i.Rating,
			&i.ReviewCount,
			&i.DiscountRate,
			&i.Keywords,
			&i.IsActive,
			&i.CreatedAt,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilteredProducts = `-- name: GetFilteredProducts :many
SELECT id, name, description, image_url, price, stock, category_id, brand, rating, review_count, discount_rate, keywords, is_active, created_at, last_updated FROM products
WHERE category_id = $1 AND price <= $2
`

type GetFilteredProductsParams struct {
	CategoryID uuid.UUID
	Price      string
}

func (q *Queries) GetFilteredProducts(ctx context.Context, arg GetFilteredProductsParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getFilteredProducts, arg.CategoryID, arg.Price)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Price,
			&i.Stock,
			&i.CategoryID,
			&i.Brand,
			&i.Rating,
			&i.ReviewCount,
			&i.DiscountRate,
			&i.Keywords,
			&i.IsActive,
			&i.CreatedAt,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaginatedProducts = `-- name: GetPaginatedProducts :many
SELECT id, name, description, image_url, price, stock, category_id, brand, rating, review_count, discount_rate, keywords, is_active, created_at, last_updated FROM products
ORDER BY created_at DESC
OFFSET $1 LIMIT $2
`

type GetPaginatedProductsParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) GetPaginatedProducts(ctx context.Context, arg GetPaginatedProductsParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getPaginatedProducts, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Price,
			&i.Stock,
			&i.CategoryID,
			&i.Brand,
			&i.Rating,
			&i.ReviewCount,
			&i.DiscountRate,
			&i.Keywords,
			&i.IsActive,
			&i.CreatedAt,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductById = `-- name: GetProductById :one
SELECT id, name, description, image_url, price, stock, category_id, brand, rating, review_count, discount_rate, keywords, is_active, created_at, last_updated FROM products
WHERE id = $1
`

func (q *Queries) GetProductById(ctx context.Context, id uuid.UUID) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProductById, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.Price,
		&i.Stock,
		&i.CategoryID,
		&i.Brand,
		&i.Rating,
		&i.ReviewCount,
		&i.DiscountRate,
		&i.Keywords,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastUpdated,
	)
	return i, err
}

const getProductWithRecommendations = `-- name: GetProductWithRecommendations :one
WITH current_product AS (
    SELECT id, name, description, image_url, price, stock, category_id, brand, rating, review_count, discount_rate, keywords, is_active, created_at, last_updated FROM products WHERE products.id = $1
)
SELECT cp.id, cp.name, cp.description, cp.image_url, cp.price, cp.stock, cp.category_id, cp.brand, cp.rating, cp.review_count, cp.discount_rate, cp.keywords, cp.is_active, cp.created_at, cp.last_updated,
    (
        SELECT jsonb_agg(jsonb_build_object('id',  rec.id, 'name',rec.name, 'price',rec.price))
        FROM products rec
        WHERE rec.category_id = cp.category_id AND rec.id != cp.id
        ORDER BY random()
        LIMIT 5
    ) AS recommendations
FROM current_product cp
`

type GetProductWithRecommendationsRow struct {
	ID              uuid.UUID
	Name            string
	Description     sql.NullString
	ImageUrl        sql.NullString
	Price           string
	Stock           int32
	CategoryID      uuid.UUID
	Brand           sql.NullString
	Rating          string
	ReviewCount     int32
	DiscountRate    string
	Keywords        sql.NullString
	IsActive        bool
	CreatedAt       time.Time
	LastUpdated     sql.NullTime
	Recommendations json.RawMessage
}

func (q *Queries) GetProductWithRecommendations(ctx context.Context, id uuid.UUID) (GetProductWithRecommendationsRow, error) {
	row := q.db.QueryRowContext(ctx, getProductWithRecommendations, id)
	var i GetProductWithRecommendationsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.Price,
		&i.Stock,
		&i.CategoryID,
		&i.Brand,
		&i.Rating,
		&i.ReviewCount,
		&i.DiscountRate,
		&i.Keywords,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.Recommendations,
	)
	return i, err
}

const getProducts = `-- name: GetProducts :many
SELECT id, name, description, image_url, price, stock, category_id, brand, rating, review_count, discount_rate, keywords, is_active, created_at, last_updated FROM products
`

func (q *Queries) GetProducts(ctx context.Context) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Price,
			&i.Stock,
			&i.CategoryID,
			&i.Brand,
			&i.Rating,
			&i.ReviewCount,
			&i.DiscountRate,
			&i.Keywords,
			&i.IsActive,
			&i.CreatedAt,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByCategory = `-- name: GetProductsByCategory :many
SELECT id, name, description, image_url, price, stock, category_id, brand, rating, review_count, discount_rate, keywords, is_active, created_at, last_updated FROM products
WHERE category_id = $1
`

func (q *Queries) GetProductsByCategory(ctx context.Context, categoryID uuid.UUID) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByCategory, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Price,
			&i.Stock,
			&i.CategoryID,
			&i.Brand,
			&i.Rating,
			&i.ReviewCount,
			&i.DiscountRate,
			&i.Keywords,
			&i.IsActive,
			&i.CreatedAt,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalesTrends = `-- name: GetSalesTrends :many
SELECT DATE_TRUNC('month', created_at) AS month, SUM(price) AS total_sales
FROM orders
GROUP BY month
ORDER BY month
`

type GetSalesTrendsRow struct {
	Month      int64
	TotalSales int64
}

func (q *Queries) GetSalesTrends(ctx context.Context) ([]GetSalesTrendsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSalesTrends)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSalesTrendsRow
	for rows.Next() {
		var i GetSalesTrendsRow
		if err := rows.Scan(&i.Month, &i.TotalSales); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrendingProducts = `-- name: GetTrendingProducts :many
WITH TrendingProducts AS (
    SELECT
        p.category_id,
        p.id AS product_id,
        SUM(oi.quantity) AS sales_volume
    FROM
        order_items oi
            JOIN orders o ON oi.order_id = o.id
            JOIN products p ON oi.product_id = p.id
    WHERE
            o.created_at > NOW() - INTERVAL '1 month'
GROUP BY
    p.category_id, p.id
    )
SELECT
    tp.product_id,
    p.name AS product_name,
    p.price,
    p.category_id,
    c.name AS category_name,
    tp.sales_volume
FROM
    TrendingProducts tp
        JOIN products p ON tp.product_id = p.id
        JOIN categories c ON p.category_id = c.id
ORDER BY
    c.name, tp.sales_volume DESC
`

type GetTrendingProductsRow struct {
	ProductID    uuid.UUID
	ProductName  string
	Price        string
	CategoryID   uuid.UUID
	CategoryName string
	SalesVolume  int64
}

func (q *Queries) GetTrendingProducts(ctx context.Context) ([]GetTrendingProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTrendingProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTrendingProductsRow
	for rows.Next() {
		var i GetTrendingProductsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductName,
			&i.Price,
			&i.CategoryID,
			&i.CategoryName,
			&i.SalesVolume,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProducts = `-- name: SearchProducts :many
SELECT id, name, description, image_url, price, stock, category_id, brand, rating, review_count, discount_rate, keywords, is_active, created_at, last_updated FROM products
WHERE name ILIKE '%' || $1 || '%' OR keywords ILIKE '%' || $1 || '%'
`

func (q *Queries) SearchProducts(ctx context.Context, dollar_1 sql.NullString) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, searchProducts, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.Price,
			&i.Stock,
			&i.CategoryID,
			&i.Brand,
			&i.Rating,
			&i.ReviewCount,
			&i.DiscountRate,
			&i.Keywords,
			&i.IsActive,
			&i.CreatedAt,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products SET
    name = $2,
    description = $3,
    image_url = $4,
    price = $5,
    stock = $6,
    category_id = $7,
    brand = $8,
    rating = $9,
    review_count = $10,
    discount_rate = $11,
    keywords = $12,
    is_active = $13,
    last_updated = NOW()
WHERE id = $1
RETURNING id, name, description, image_url, price, stock, category_id, brand, rating, review_count, discount_rate, keywords, is_active, created_at, last_updated
`

type UpdateProductParams struct {
	ID           uuid.UUID
	Name         string
	Description  sql.NullString
	ImageUrl     sql.NullString
	Price        string
	Stock        int32
	CategoryID   uuid.UUID
	Brand        sql.NullString
	Rating       string
	ReviewCount  int32
	DiscountRate string
	Keywords     sql.NullString
	IsActive     bool
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, updateProduct,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.ImageUrl,
		arg.Price,
		arg.Stock,
		arg.CategoryID,
		arg.Brand,
		arg.Rating,
		arg.ReviewCount,
		arg.DiscountRate,
		arg.Keywords,
		arg.IsActive,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.Price,
		&i.Stock,
		&i.CategoryID,
		&i.Brand,
		&i.Rating,
		&i.ReviewCount,
		&i.DiscountRate,
		&i.Keywords,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastUpdated,
	)
	return i, err
}
