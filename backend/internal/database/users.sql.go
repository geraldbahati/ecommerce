// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: users.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const activateUser = `-- name: ActivateUser :one
UPDATE users SET
    account_status = 'active'
WHERE id = $1
RETURNING id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth
`

func (q *Queries) ActivateUser(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, activateUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Gender,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.CreatedAt,
		&i.LastLogin,
		&i.AccountStatus,
		&i.UserRole,
		&i.ProfilePicture,
		&i.TwoFactorAuth,
	)
	return i, err
}

const countActiveUsers = `-- name: CountActiveUsers :one
SELECT COUNT(*) FROM users
WHERE account_status = 'active'
`

func (q *Queries) CountActiveUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActiveUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAdminUsers = `-- name: CountAdminUsers :one
SELECT COUNT(*) FROM users
WHERE user_role = 'admin'
`

func (q *Queries) CountAdminUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAdminUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAllUsers = `-- name: CountAllUsers :one
SELECT COUNT(*) FROM users
`

func (q *Queries) CountAllUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCustomers = `-- name: CountCustomers :one
SELECT COUNT(*) FROM users
WHERE user_role = 'customer'
`

func (q *Queries) CountCustomers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCustomers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDeletedUsers = `-- name: CountDeletedUsers :one
SELECT COUNT(*) FROM users
WHERE account_status = 'deleted'
`

func (q *Queries) CountDeletedUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDeletedUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countInactiveUsers = `-- name: CountInactiveUsers :one
SELECT COUNT(*) FROM users
WHERE account_status = 'inactive'
`

func (q *Queries) CountInactiveUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countInactiveUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSuperAdminUsers = `-- name: CountSuperAdminUsers :one
SELECT COUNT(*) FROM users
WHERE user_role = 'superadmin'
`

func (q *Queries) CountSuperAdminUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSuperAdminUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSuspendedUsers = `-- name: CountSuspendedUsers :one
SELECT COUNT(*) FROM users
WHERE account_status = 'suspended'
`

func (q *Queries) CountSuspendedUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSuspendedUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (id, email, hashed_password, username, first_name, last_name, user_role)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth
`

type CreateUserParams struct {
	ID             uuid.UUID
	Email          string
	HashedPassword string
	Username       string
	FirstName      string
	LastName       string
	UserRole       string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.Email,
		arg.HashedPassword,
		arg.Username,
		arg.FirstName,
		arg.LastName,
		arg.UserRole,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Gender,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.CreatedAt,
		&i.LastLogin,
		&i.AccountStatus,
		&i.UserRole,
		&i.ProfilePicture,
		&i.TwoFactorAuth,
	)
	return i, err
}

const deactivateUser = `-- name: DeactivateUser :one
UPDATE users SET
    account_status = 'inactive'
WHERE id = $1
RETURNING id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth
`

func (q *Queries) DeactivateUser(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, deactivateUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Gender,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.CreatedAt,
		&i.LastLogin,
		&i.AccountStatus,
		&i.UserRole,
		&i.ProfilePicture,
		&i.TwoFactorAuth,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
UPDATE users SET
    account_status = 'deleted'
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const demoteUserToCustomer = `-- name: DemoteUserToCustomer :one
UPDATE users SET
    user_role = 'customer'
WHERE id = $1
RETURNING id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth
`

func (q *Queries) DemoteUserToCustomer(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, demoteUserToCustomer, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Gender,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.CreatedAt,
		&i.LastLogin,
		&i.AccountStatus,
		&i.UserRole,
		&i.ProfilePicture,
		&i.TwoFactorAuth,
	)
	return i, err
}

const disableTwoFactorAuth = `-- name: DisableTwoFactorAuth :one
UPDATE users SET
    two_factor_auth = FALSE
WHERE id = $1
RETURNING id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth
`

func (q *Queries) DisableTwoFactorAuth(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, disableTwoFactorAuth, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Gender,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.CreatedAt,
		&i.LastLogin,
		&i.AccountStatus,
		&i.UserRole,
		&i.ProfilePicture,
		&i.TwoFactorAuth,
	)
	return i, err
}

const enableTwoFactorAuth = `-- name: EnableTwoFactorAuth :one
UPDATE users SET
    two_factor_auth = TRUE
WHERE id = $1
RETURNING id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth
`

func (q *Queries) EnableTwoFactorAuth(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, enableTwoFactorAuth, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Gender,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.CreatedAt,
		&i.LastLogin,
		&i.AccountStatus,
		&i.UserRole,
		&i.ProfilePicture,
		&i.TwoFactorAuth,
	)
	return i, err
}

const findUserByEmail = `-- name: FindUserByEmail :one
SELECT id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth FROM users
WHERE email = $1
`

func (q *Queries) FindUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, findUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Gender,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.CreatedAt,
		&i.LastLogin,
		&i.AccountStatus,
		&i.UserRole,
		&i.ProfilePicture,
		&i.TwoFactorAuth,
	)
	return i, err
}

const findUserByID = `-- name: FindUserByID :one
SELECT id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth FROM users
WHERE id = $1
`

func (q *Queries) FindUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, findUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Gender,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.CreatedAt,
		&i.LastLogin,
		&i.AccountStatus,
		&i.UserRole,
		&i.ProfilePicture,
		&i.TwoFactorAuth,
	)
	return i, err
}

const findUserByPassword = `-- name: FindUserByPassword :one
SELECT id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth FROM users
WHERE hashed_password = $1
`

func (q *Queries) FindUserByPassword(ctx context.Context, hashedPassword string) (User, error) {
	row := q.db.QueryRowContext(ctx, findUserByPassword, hashedPassword)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Gender,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.CreatedAt,
		&i.LastLogin,
		&i.AccountStatus,
		&i.UserRole,
		&i.ProfilePicture,
		&i.TwoFactorAuth,
	)
	return i, err
}

const findUserByUsername = `-- name: FindUserByUsername :one
SELECT id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth FROM users
WHERE username = $1
`

func (q *Queries) FindUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, findUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Gender,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.CreatedAt,
		&i.LastLogin,
		&i.AccountStatus,
		&i.UserRole,
		&i.ProfilePicture,
		&i.TwoFactorAuth,
	)
	return i, err
}

const getActiveUsers = `-- name: GetActiveUsers :many
SELECT id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth FROM users
WHERE account_status = 'active'
LIMIT $1 OFFSET $2
`

type GetActiveUsersParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetActiveUsers(ctx context.Context, arg GetActiveUsersParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getActiveUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.HashedPassword,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
			&i.DateOfBirth,
			&i.Gender,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.CreatedAt,
			&i.LastLogin,
			&i.AccountStatus,
			&i.UserRole,
			&i.ProfilePicture,
			&i.TwoFactorAuth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAdminUsers = `-- name: GetAdminUsers :many
SELECT id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth FROM users
WHERE user_role = 'admin'
LIMIT $1 OFFSET $2
`

type GetAdminUsersParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetAdminUsers(ctx context.Context, arg GetAdminUsersParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getAdminUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.HashedPassword,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
			&i.DateOfBirth,
			&i.Gender,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.CreatedAt,
			&i.LastLogin,
			&i.AccountStatus,
			&i.UserRole,
			&i.ProfilePicture,
			&i.TwoFactorAuth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth FROM users
LIMIT $1 OFFSET $2
`

type GetAllUsersParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetAllUsers(ctx context.Context, arg GetAllUsersParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.HashedPassword,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
			&i.DateOfBirth,
			&i.Gender,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.CreatedAt,
			&i.LastLogin,
			&i.AccountStatus,
			&i.UserRole,
			&i.ProfilePicture,
			&i.TwoFactorAuth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomers = `-- name: GetCustomers :many
SELECT id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth FROM users
WHERE user_role = 'customer'
LIMIT $1 OFFSET $2
`

type GetCustomersParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetCustomers(ctx context.Context, arg GetCustomersParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getCustomers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.HashedPassword,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
			&i.DateOfBirth,
			&i.Gender,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.CreatedAt,
			&i.LastLogin,
			&i.AccountStatus,
			&i.UserRole,
			&i.ProfilePicture,
			&i.TwoFactorAuth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeletedUsers = `-- name: GetDeletedUsers :many
SELECT id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth FROM users
WHERE account_status = 'deleted'
LIMIT $1 OFFSET $2
`

type GetDeletedUsersParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetDeletedUsers(ctx context.Context, arg GetDeletedUsersParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getDeletedUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.HashedPassword,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
			&i.DateOfBirth,
			&i.Gender,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.CreatedAt,
			&i.LastLogin,
			&i.AccountStatus,
			&i.UserRole,
			&i.ProfilePicture,
			&i.TwoFactorAuth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInactiveUsers = `-- name: GetInactiveUsers :many
SELECT id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth FROM users
WHERE account_status = 'inactive'
LIMIT $1 OFFSET $2
`

type GetInactiveUsersParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetInactiveUsers(ctx context.Context, arg GetInactiveUsersParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getInactiveUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.HashedPassword,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
			&i.DateOfBirth,
			&i.Gender,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.CreatedAt,
			&i.LastLogin,
			&i.AccountStatus,
			&i.UserRole,
			&i.ProfilePicture,
			&i.TwoFactorAuth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSuperAdminUsers = `-- name: GetSuperAdminUsers :many
SELECT id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth FROM users
WHERE user_role = 'superadmin'
LIMIT $1 OFFSET $2
`

type GetSuperAdminUsersParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetSuperAdminUsers(ctx context.Context, arg GetSuperAdminUsersParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getSuperAdminUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.HashedPassword,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
			&i.DateOfBirth,
			&i.Gender,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.CreatedAt,
			&i.LastLogin,
			&i.AccountStatus,
			&i.UserRole,
			&i.ProfilePicture,
			&i.TwoFactorAuth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSuspendedUsers = `-- name: GetSuspendedUsers :many
SELECT id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth FROM users
WHERE account_status = 'suspended'
LIMIT $1 OFFSET $2
`

type GetSuspendedUsersParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetSuspendedUsers(ctx context.Context, arg GetSuspendedUsersParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getSuspendedUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.HashedPassword,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
			&i.DateOfBirth,
			&i.Gender,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.CreatedAt,
			&i.LastLogin,
			&i.AccountStatus,
			&i.UserRole,
			&i.ProfilePicture,
			&i.TwoFactorAuth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const partialFindUsersByUsername = `-- name: PartialFindUsersByUsername :many
SELECT id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth FROM users
WHERE username LIKE $1
LIMIT $2 OFFSET $3
`

type PartialFindUsersByUsernameParams struct {
	Username string
	Limit    int32
	Offset   int32
}

func (q *Queries) PartialFindUsersByUsername(ctx context.Context, arg PartialFindUsersByUsernameParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, partialFindUsersByUsername, arg.Username, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.HashedPassword,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
			&i.DateOfBirth,
			&i.Gender,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.CreatedAt,
			&i.LastLogin,
			&i.AccountStatus,
			&i.UserRole,
			&i.ProfilePicture,
			&i.TwoFactorAuth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const promoteUserToAdmin = `-- name: PromoteUserToAdmin :one
UPDATE users SET
    user_role = 'admin'
WHERE id = $1
RETURNING id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth
`

func (q *Queries) PromoteUserToAdmin(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, promoteUserToAdmin, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Gender,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.CreatedAt,
		&i.LastLogin,
		&i.AccountStatus,
		&i.UserRole,
		&i.ProfilePicture,
		&i.TwoFactorAuth,
	)
	return i, err
}

const promoteUserToSuperAdmin = `-- name: PromoteUserToSuperAdmin :one
UPDATE users SET
    user_role = 'superadmin'
WHERE id = $1
RETURNING id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth
`

func (q *Queries) PromoteUserToSuperAdmin(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, promoteUserToSuperAdmin, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Gender,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.CreatedAt,
		&i.LastLogin,
		&i.AccountStatus,
		&i.UserRole,
		&i.ProfilePicture,
		&i.TwoFactorAuth,
	)
	return i, err
}

const recoverUser = `-- name: RecoverUser :one
UPDATE users SET
    account_status = 'active'
WHERE id = $1
RETURNING id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth
`

func (q *Queries) RecoverUser(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, recoverUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Gender,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.CreatedAt,
		&i.LastLogin,
		&i.AccountStatus,
		&i.UserRole,
		&i.ProfilePicture,
		&i.TwoFactorAuth,
	)
	return i, err
}

const suspendUser = `-- name: SuspendUser :one
UPDATE users SET
    account_status = 'suspended'
WHERE id = $1
RETURNING id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth
`

func (q *Queries) SuspendUser(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, suspendUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Gender,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.CreatedAt,
		&i.LastLogin,
		&i.AccountStatus,
		&i.UserRole,
		&i.ProfilePicture,
		&i.TwoFactorAuth,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users SET
    username = $2,
    email = $3,
    first_name = $4,
    last_name = $5,
    phone_number = $6,
    date_of_birth = $7,
    gender = $8,
    shipping_address = $9,
    billing_address = $10
WHERE id = $1
RETURNING id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth
`

type UpdateUserParams struct {
	ID              uuid.UUID
	Username        string
	Email           string
	FirstName       string
	LastName        string
	PhoneNumber     sql.NullString
	DateOfBirth     sql.NullTime
	Gender          sql.NullString
	ShippingAddress sql.NullString
	BillingAddress  sql.NullString
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.ID,
		arg.Username,
		arg.Email,
		arg.FirstName,
		arg.LastName,
		arg.PhoneNumber,
		arg.DateOfBirth,
		arg.Gender,
		arg.ShippingAddress,
		arg.BillingAddress,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Gender,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.CreatedAt,
		&i.LastLogin,
		&i.AccountStatus,
		&i.UserRole,
		&i.ProfilePicture,
		&i.TwoFactorAuth,
	)
	return i, err
}

const updateUserLastLogin = `-- name: UpdateUserLastLogin :exec
UPDATE users SET
    last_login = $2
WHERE id = $1
`

type UpdateUserLastLoginParams struct {
	ID        uuid.UUID
	LastLogin sql.NullTime
}

func (q *Queries) UpdateUserLastLogin(ctx context.Context, arg UpdateUserLastLoginParams) error {
	_, err := q.db.ExecContext(ctx, updateUserLastLogin, arg.ID, arg.LastLogin)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :one
UPDATE users SET
    hashed_password = $2
WHERE id = $1
RETURNING id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth
`

type UpdateUserPasswordParams struct {
	ID             uuid.UUID
	HashedPassword string
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserPassword, arg.ID, arg.HashedPassword)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Gender,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.CreatedAt,
		&i.LastLogin,
		&i.AccountStatus,
		&i.UserRole,
		&i.ProfilePicture,
		&i.TwoFactorAuth,
	)
	return i, err
}

const updateUserProfilePicture = `-- name: UpdateUserProfilePicture :one
UPDATE users SET
    profile_picture = $2
WHERE id = $1
RETURNING id, username, email, hashed_password, first_name, last_name, phone_number, date_of_birth, gender, shipping_address, billing_address, created_at, last_login, account_status, user_role, profile_picture, two_factor_auth
`

type UpdateUserProfilePictureParams struct {
	ID             uuid.UUID
	ProfilePicture sql.NullString
}

func (q *Queries) UpdateUserProfilePicture(ctx context.Context, arg UpdateUserProfilePictureParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserProfilePicture, arg.ID, arg.ProfilePicture)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Gender,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.CreatedAt,
		&i.LastLogin,
		&i.AccountStatus,
		&i.UserRole,
		&i.ProfilePicture,
		&i.TwoFactorAuth,
	)
	return i, err
}
